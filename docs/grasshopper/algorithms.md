---
order: 35
---

# アルゴリズム解説（主要機能の仕組みと選定基準）

Grasshopperでは、コンポーネントの選択によって結果が大きく変化します。本ページでは、**主要機能の仕組み（何を保証し、何を最適化しているか）**を、実務判断に必要な範囲で整理します。

- 目的: “暗記”ではなく、**選択理由**を説明できる状態にする
- 範囲: 実装の数式を網羅するのではなく、**挙動差が出る要点**に限定する
- **前提**: 本ページの説明は、Grasshopper標準コンポーネント（Rhino 7/8共通）を前提とします。プラグインコンポーネントの場合は明記します。

## 例題：点列からCurveを作る（選定基準とアルゴリズムの要点）

### 選定の結論（用途別の第一候補）

- **点が「必ず通過すべき条件」** → **Interpolate（補間）**
- **点が測定/スキャン等でノイズを含む** → **Fit Curve（近似）**
  - ノイズが含まれていてもっともらしい曲線が欲しい場合に推奨
  - 許容誤差を調整することで、滑らかさと精度のバランスを制御できる
- **折れ線が欲しい（角を残したい）** → **Polyline**
- **LINE（直線）とARC（円弧）で構成された幾何学セグメントで点列を再現したい** → **Fit Line / Fit Arc / セグメント分割**
  - CAD/CAMで扱いやすい形式（直線・円弧の組み合わせ）が必要な場合に推奨
- **「制御点（Control Points）を直接いじる」設計にしたい** → **Nurbs Curve（Control Points入力）**

### 事前に確定すべき3点

- **点の意味**: すべての点を通過させる必要があるか（補間）／誤差内で近似できるか（近似）
- **点の品質**: ノイズ（ばらつき）の有無、重複点の有無、順序の正しさ
- **欲しい曲線の性質**: 角を残す/滑らかにする、閉じる/開く、接線条件が必要か

## Interpolate（補間）：点列を通過する曲線を構成する

Grasshopperの `Interpolate` 系は、基本的に **NURBS曲線**を作ります。

- **保証**: 指定した点列を**必ず通過する**（理論的には完全に一致）
- **数値計算の誤差**: 浮動小数点演算の誤差により、完全に一致しない場合がある。Rhinoの公差設定（`DocumentProperties` → Units → Absolute tolerance、デフォルトはドキュメント単位に依存）内で一致することが多いが、補間点が極端に不規則な場合は誤差が大きくなる場合がある
- **注意**: 点が多い、または点列にノイズが含まれる場合、局所的な曲率の増大や振動（不要なうねり）が生じやすい

### Catmull-Romスプラインとの違い

「すべての点を通す曲線」としてCatmull-Romスプラインをイメージする場合がありますが、Grasshopperの `Interpolate` は異なるアプローチを採用しています。

**Catmull-Romスプラインの特徴**:
- 4点（\(P_{i-1}, P_i, P_{i+1}, P_{i+2}\)）を使って、\(P_i\) と \(P_{i+1}\) の間のセグメントを局所的に生成
- 通常は均等パラメータ化（uniform parameterization）を使用
- 端点の扱いが特殊（端点を通さない場合がある、または特別な処理が必要）

**Grasshopperの `Interpolate`（NURBS補間）の特徴**:
- 点列全体を一度に解いて、すべての点を通過する制御点とノット配置を決定
- デフォルトで弦長パラメータ化（chord length parameterization）を使用（点間距離を反映）。`Interpolate`コンポーネントのパラメータ化オプションで変更可能
- 端点を必ず通過する（開いた曲線の場合）
- 次数（degree）を変更可能。デフォルトは3（3次NURBS曲線）。次数を変更すると、滑らかさと制御のバランスが変わる

**なぜNURBS補間を使うのか**:
- RhinoのジオメトリエンジンがNURBSを標準として扱うため、他のNURBS操作（ブーリアン、フィレット、サーフェス生成など）との互換性が高い
- パラメータ化の選択肢（弦長/均等）により、点間距離の影響を制御できる
- 次数を変更することで、滑らかさと局所的な制御のバランスを調整できる

### Catmull-Romスプラインを使いたい場合

Grasshopperの標準コンポーネントには、Catmull-Romスプラインを直接生成する機能はありません。Catmull-Romスプラインが必要な場合は、次の方法があります。

**方法1: Pythonスクリプトで実装する**

GrasshopperのPythonコンポーネントを使用して、RhinoCommonの`Curve.CreateCatmullRomSpline`メソッドを呼び出します。

```python
import Rhino.Geometry as rg

# inputs:
#   pts: Point3d[] (点列)

if pts and len(pts) >= 2:
    # Catmull-Romスプラインを生成
    # 端点を通す場合は closed=False
    crv = rg.Curve.CreateCatmullRomSpline(pts, closed=False)
    if crv:
        # outputs:
        #   crv: Curve
        a = crv
    else:
        a = None
else:
    a = None
```

**方法2: Interpolateで近似する**

`Interpolate`コンポーネントで均等パラメータ化（uniform parameterization）を指定すると、Catmull-Romスプラインに近い挙動になります。ただし、完全に同じにはなりません。

- `Interpolate`コンポーネントのパラメータ化オプションを「Uniform」に設定
- 点列が均等間隔に近い場合、結果がCatmull-Romに近づく

**方法3: プラグインを探す**

GrasshopperのコミュニティプラグインにCatmull-Romスプラインを提供するものがある可能性があります（推測）。標準機能ではないため、プラグインのメンテナンス状況や互換性を確認する必要があります。確認方法: Grasshopperのプラグインマネージャーやコミュニティフォーラムで検索する。

**Catmull-Romが必要な場面**:
- アニメーション/ゲーム開発で、既存のパイプラインと互換性が必要
- 局所的な4点補間の挙動が設計要件に合致している
- 均等パラメータ化による予測可能な挙動が必要

### アルゴリズムの要点：なぜ制御点で補間点を通せるのか

NURBS曲線は**制御点（control points）**で定義されますが、制御点は通常補間点とは異なる位置にあります。では、なぜ補間点を通る曲線を作れるのでしょうか。

**補間の仕組み（逆算問題）**:

1. **制御点の数と補間点の数の関係**
   - 次数\(p\)のNURBS曲線で\(n\)個の補間点を通るには、**\(n\)個の制御点**が必要です（端点条件が標準的な場合）
   - 補間点の数と制御点の数は**1対1対応**します（\(n\)個の補間点 → \(n\)個の制御点）
   - ただし、制御点は補間点の「単純な関数」\(p = f(v)\) ではなく、**線形システムとして解く**必要があります
   - **例外**: 閉じた曲線や特殊な端点条件の場合、制御点の数が変わる場合がある

2. **連立方程式として解く（線形システム）**
   - 各補間点\(V_i\)について、「NURBS曲線の式にパラメータ\(u_i\)を代入した結果が\(V_i\)になる」という条件を立てます
   - NURBS曲線の式:
     \[
     C(u) = \sum_{j} N_{j,p}(u) \cdot P_j
     \]
     （\(P_j\)は制御点、\(N_{j,p}(u)\)は基底関数）
   - 各補間点\(V_i\)について:
     \[
     V_i = \sum_{j} N_{j,p}(u_i) \cdot P_j
     \]
   - これにより、\(n\)個の補間点から\(n\)個の方程式ができます
   - 未知数は制御点の座標（\(n\)個×3次元 = \(3n\)個）です
   - ノットベクトル（knot vector）を先に決めれば、基底関数\(N_{j,p}(u_i)\)が確定し、**線形システム \(A \cdot P = V\)** として解けます
     - \(A\): \(n \times n\)行列（基底関数の値で構成）
     - \(P\): \(n \times 3\)行列（制御点の座標）
     - \(V\): \(n \times 3\)行列（補間点の座標）
   - **補間点を必ず通る理由**: この連立方程式は、補間点の数と制御点の数が一致する場合、**理論的には完全に解ける**ため、補間点を必ず通る曲線が存在します
   - **数値計算の現実**: 実際の計算では浮動小数点演算の誤差が発生します。Rhinoの公差設定（`DocumentProperties` → Units → Absolute tolerance）内で一致することが多いが、補間点が極端に不規則な場合や点数が非常に多い場合は誤差が大きくなる場合がある

3. **1対1対応だが、単純な関数ではない**
   - 補間点\(V_i\)と制御点\(P_j\)は1対1対応しますが、\(P_j = f(V_j)\) という単純な関数関係ではありません
   - 各制御点\(P_j\)は、**すべての補間点\(V_1, V_2, \ldots, V_n\)**の情報を使って決定されます
   - つまり、次の形になり、各制御点は全補間点の線形結合です:
     \[
     P_j = \sum_{i} A^{-1}_{j,i} \cdot V_i
     \]
     （\(A^{-1}\)は逆行列）

4. **微分可能性**
   - 補間点\(V\)から制御点\(P\)への写像は**線形写像**（\(P = A^{-1} \cdot V\)）なので、**微分可能**です
   - ノットベクトルが固定されている場合、\(A\)は定数行列なので、\(P = A^{-1} \cdot V\) は線形で、微分は定数行列\(A^{-1}\)になります
   - ノットベクトルも補間点に依存する場合（弦長パラメータ化など）、非線形になりますが、それでも**微分可能**です
   - NURBS曲線\(C(u)\)自体も、パラメータ\(u\)について**無限回微分可能**です（次数3の場合、\(C^2\)連続が保証されます）

5. **制御点から補間点への逆方向の計算**
   - **制御点\(P_j\)がわかれば、補間点\(V_i\)は原理的に計算可能**です
   - 補間点\(V_i\)は、パラメータ値\(u_i\)でNURBS曲線を評価した結果:
     \[
     V_i = C(u_i) = \sum_{j} N_{j,p}(u_i) \cdot P_j
     \]
   - これは**単純な計算**で、連立方程式を解く必要はありません（基底関数\(N_{j,p}(u_i)\)の値と制御点\(P_j\)の線形結合を計算するだけ）
   - ただし、**どのパラメータ値\(u_i\)で評価するか**を決める必要があります（元の補間問題で使ったノットベクトル/パラメータ化を覚えておく必要がある）
   - **非対称性**: 補間点→制御点は連立方程式を解く必要があるが、制御点→補間点は単純な評価計算で済む

6. **ノットベクトルの決定**
   - ノットベクトルは、各補間点に対応するパラメータ値\(u_i\)を定義します
   - 弦長パラメータ化: \(u_i\)は累積弦長に比例（点間距離を反映）
   - 均等パラメータ化: \(u_i\)は均等に割り当て（\(0, \frac{1}{n-1}, \frac{2}{n-1}, \ldots, 1\)）
   - ノットベクトルが決まると、基底関数\(N_{i,p}(u)\)が確定し、連立方程式が解けます

7. **端点条件の扱い**
   - 開いた曲線の場合、端点を必ず通すように制約を追加します
   - 閉じた曲線の場合、最初と最後の点を一致させます

**なぜ振動が起きるのか**:
- 補間点が不規則に配置されている場合、ノットベクトルと補間点の対応が不自然になり、基底関数の組み合わせで大きな係数が発生することがあります
- これにより、制御点が補間点から大きく外れた位置に配置され、曲線が「暴れる」ことがあります

**N個の補間点で生成されるNURBS曲線の構造**:

N個の補間点が与えられた場合、**1本のNURBS曲線**が生成されます。ただし、この曲線は内部的に複数のセグメント（区間）で構成されています。

- **セグメント数**: 次数3の場合、\(n\)個の補間点に対して**\(n-3\)個のセグメント**が生成されます
  - 例: 10個の補間点 → 7個のセグメント
  - 例: 1000個の補間点 → 997個のセグメント
  - 各セグメントは、隣接するセグメントとC²連続（曲率連続）で接続されます
- **セグメント数の計算式**: セグメント数 = 補間点数 - 次数
  - これは、ノットベクトルの構造（端点に次数+1個の重複ノット、内部に\(n-\text{次数}-1\)個のノット）から導かれます
- **1本の曲線として扱われる**: セグメントは内部的に分割されていますが、外部的には1本の連続したNURBS曲線として扱われます
  - `Divide Curve`で分割したり、`Evaluate Curve`で任意のパラメータ値を評価したりできます
- **セグメント境界**: セグメントの境界は、ノットベクトル内の「重複ノット」の位置に対応します
  - 次数3の場合、ノットベクトルは通常 \([0,0,0,0, u_1, u_2, \ldots, u_{n-3}, 1,1,1,1]\) の形式になります
  - 端点（0と1）には次数+1個の重複ノットがあり、内部ノットは補間点に対応します

**なぜセグメント化されるのか**:
- 各セグメントは局所的に制御可能です（局所的な変更が他の部分に影響しにくい）
- しかし、次数が高い場合や補間点が多い場合、1本の長い曲線として扱う方が効率的です
- セグメント境界は、補間点の位置とノットベクトルの構造から自動的に決まります

**NURBS曲線の形状を決める要素**:

- **次数（degree）**: 滑らかさを制御するパラメータ
  - 次数が高いほど滑らかだが、制御が難しくなる
  - 次数3（3次NURBS）は、滑らかさと制御のバランスが良いため、多くの場合に使用される。ただし、角を保持したい場合や制御点を直接編集したい場合は次数を下げる（1次=折れ線、2次=2次曲線）こともある
  - 次数\(p\)の場合、各セグメントは\(p\)次多項式で表現されます
- **ノット（knot / パラメータ化）**: 点列を曲線パラメータ上でどのような間隔として扱うか
  - 弦長パラメータ化: 点間の実際の距離を反映（点が密な箇所はパラメータ間隔が狭い）
  - 均等パラメータ化: 点間の距離に関係なく均等にパラメータを割り当て
  - ノットベクトルの構造がセグメント境界を決定します
- **制御点（control points）**: 曲線を規定する点（補間点そのものではない）
  - 補間の場合、制御点は補間点を通るように逆算で決定される
  - 制御点は補間点から離れた位置にあることが多い（特に点が不規則な場合）
  - 制御点の数は、補間点の数と次数から決まります。標準的な端点条件の場合、補間点数と同じになる。閉じた曲線や特殊な端点条件の場合は異なる場合がある

### 実務上の指針（安定化のための要点）

- **点の順序を保証する**（順序が不適切だと自己交差・蛇行の原因になる）
- **重複点を除去する**（同一点が連続すると不安定化しやすい）
- **過剰な点数を避ける**（必要以上の点は振動の原因になりやすい）
- **角を保持したい場合は補間に依存しない**（`Polyline` を基準に、必要箇所のみ `Fillet` / `Blend` を適用する方が制御しやすい）

## Fit Curve（近似）：誤差許容内で点列に近似する

`Fit Curve` 系は、点列を **誤差（許容値）以内**で近似する曲線を作ります。

- **保証**: すべての点を通過させるのではなく、許容誤差内で近似する
- **適用場面**: 点列がノイズを含む（測定/スキャン/サンプル等）
- **調整の要点**: 許容誤差を小さくすると補間に近づき、大きくすると滑らかになる一方、形状差も大きくなる

## Polyline（折れ線）：角を保持しつつ点列を接続する

角を保持したい場合は、`Polyline` を第一候補とするのが安全です。

- **保証**: 点を直線で結ぶ（挙動が明確）
- **後処理**: 必要に応じて局所的に `Fillet` / `Blend` / `Chamfer` を適用する

## LINE（直線）とARC（円弧）で構成された幾何学セグメントで点列を再現する

CAD/CAMで扱いやすい形式（直線・円弧の組み合わせ）が必要な場合、点列を直線セグメントと円弧セグメントに分割して近似します。

### 基本的なアプローチ

**方法1: 点列を直接セグメントに分割する**

1. **点列をセグメントに分割する**
   - 点列を複数のグループに分割し、各グループが直線または円弧で近似できるようにする
   - 分割点は、曲率が大きい箇所や方向が変わる箇所を基準にする

2. **各セグメントに直線または円弧をフィットする**
- **直線セグメント**: `Fit Line`コンポーネント（Curve → Utilカテゴリ）を使用。最小二乗法で直線をフィットする（Grasshopper標準機能）
- **円弧セグメント**: `Fit Arc`コンポーネント（Curve → Utilカテゴリ）を使用。最小二乗法で円弧をフィットする（Grasshopper標準機能）
   - 許容誤差を設定して、フィットの精度を制御する

3. **セグメントを接続する**
   - 直線と円弧のセグメントを順番に接続して、連続した曲線（PolyCurve）を作成する
   - 接続点での連続性（位置・接線）を確認する

**方法2: NURBS曲線を作成してから曲率分析で自動セグメント化する（推奨）**

1. **まずNURBS曲線を作成する**
   - 点列から`Interpolate`または`Fit Curve`でNURBS曲線を作成
   - 滑らかな曲線として一度表現する

2. **曲率を分析する**
   - `Curvature`コンポーネント（Curve → Analysisカテゴリ）で曲線上の各点の曲率を計算（Grasshopper標準機能）
   - 曲率の変化率（曲率の微分）を分析して、セグメント境界を自動検出
   - **曲率がほぼ0の領域** → 直線セグメント候補
   - **曲率がほぼ一定の領域** → 円弧セグメント候補
   - **曲率が急変する箇所** → セグメント境界

3. **セグメント境界で分割する**
   - 検出した境界点で曲線を分割（`Divide Curve`または`Split Curve`）
   - 各セグメントに対して`Fit Line`または`Fit Arc`を適用

4. **セグメントを再構築する**
   - フィットした直線・円弧を`Join Curves`で接続
   - 必要に応じて、接続点での連続性を調整

**曲率分析による自動セグメント化の利点**:
- 点列のノイズの影響を受けにくい（一度NURBSで滑らかにしてから分析）
- 曲率の変化を定量的に評価できる
- セグメント境界の判断が客観的になる

**実装のヒント**:
- 曲率の閾値を設定して、直線（曲率 < 閾値）と円弧（曲率 > 閾値）を判別
- 曲率の変化率（曲率の微分）が大きい箇所をセグメント境界として検出
- GrasshopperのPythonコンポーネント（`Script`コンポーネント）で曲率分析と自動分割を実装することも可能。RhinoCommonのAPIを使用して、曲率計算とセグメント分割のロジックを記述する

### 曲率の可視化方法

Grasshopperで曲線の曲率を可視化するには、以下の方法があります。

**方法1: Curvature Graphコンポーネント（標準機能）**

- `Curvature Graph`コンポーネント（Curve → Analysisカテゴリ）を使用（Grasshopper標準機能）
- 入力: Curve（分析対象の曲線）
- 出力: 曲率を可視化したジオメトリ（曲線上の各点から曲率半径に比例した長さの線分が表示される）
- 曲率が大きい箇所（半径が小さい）ほど、線分が長く表示される
- 曲率の方向も可視化される（曲線の法線方向に線分が伸びる）

**方法2: 手動で曲率を計算して可視化**

1. `Divide Curve`で曲線を分割し、評価点を取得
2. 各点で`Curvature`コンポーネントを使用して曲率を計算
   - 出力: 曲率ベクトル（大きさと方向）
3. `Vector Display`または`Line`コンポーネントで曲率ベクトルを可視化
   - 曲率の大きさに比例した長さの線分を描画

**方法3: 曲率のグラフ化（数値として可視化）**

1. `Divide Curve`で曲線を分割
2. 各点で`Curvature`を計算し、曲率の大きさ（スカラー値）を取得
3. `Graph Mapper`や`Line`コンポーネントで、パラメータ位置と曲率の関係をグラフ化
   - X軸: 曲線のパラメータ値（0〜1）
   - Y軸: 曲率の大きさ

**曲率変化の可視化**

曲率の変化率（曲率の微分）を可視化するには：

1. `Divide Curve`で曲線を細かく分割
2. 各点で曲率を計算
3. 隣接する点間の曲率の差分を計算（`Subtract`コンポーネントなど）
4. 差分の大きさを`Vector Display`や`Graph Mapper`で可視化
   - 差分が大きい箇所 = 曲率が急変する箇所 = セグメント境界の候補

**実用的なワークフロー例**:

```
Curve → Divide Curve（細かく分割） → Curvature（各点で計算） → 
→ [曲率の可視化] Vector Display / Curvature Graph
→ [曲率変化の可視化] 隣接点間の差分計算 → Graph Mapper / Vector Display
```

### Grasshopperでの実装例

**方法1（直接分割）**:
```
点列 → セグメント分割（手動または自動） → 各セグメントに Fit Line / Fit Arc → Join Curves
```

**方法2（曲率分析による自動分割、推奨）**:
```
点列 → Interpolate/Fit Curve → Curvature分析 → セグメント境界検出 → Split Curve → 各セグメントに Fit Line / Fit Arc → Join Curves
```

### 適用場面

- **CAD/CAMでの加工**: 直線・円弧の組み合わせが加工しやすい
- **図面化**: 直線・円弧で表現できる形状を明確にしたい
- **データ量の削減**: NURBS曲線より単純な表現で済む場合がある

### 注意点

- **セグメント分割の判断**: どこで直線と円弧を切り替えるかの判断が重要
- **許容誤差の設定**: 各セグメントのフィット誤差を許容範囲内に収める必要がある
- **連続性**: セグメント間の接続で、位置や接線の連続性を保つ必要がある場合がある

## 典型ワークフロー（点列→Curveを安定させる）

点列から曲線を生成する際の基本フローを示します。

```mermaid
flowchart LR
  P[Points] --> C1[Clean: Cull Duplicates / Simplify Tree]
  C1 --> C2[Order: sort / ensure sequence]
  C2 --> M{目的}
  M -->|通る必要あり| I[Interpolate]
  M -->|ノイズあり| F[Fit Curve]
  M -->|角が欲しい| L[Polyline]
  M -->|直線/円弧| LA[Fit Line/Arc + Join]
  I --> OUT[Curve]
  F --> OUT
  L --> OUT
  LA --> OUT
```

## よくある失敗とチェックリスト

- **点の順序が不適切**（自己交差・蛇行が発生する）  
  - 対策: 点列の順序を作る工程を定義内に明示し、暗黙にListへ投入しない
- **重複点／過密点が混在**（局所で曲率が増大する）  
  - 対策: 重複除去、最小間隔の確保（必要に応じて間引き）
- **ノイズ点に対してInterpolateを適用**（不要な振動が発生する）  
  - 対策: `Fit Curve` へ切り替える（推奨）、または点列を平滑化してから補間する
  - `Fit Curve`を使用する場合、ノイズの大きさを推定して適切な許容誤差を設定する
- **Data Tree構造の影響で意図しない曲線が複数生成される**  
  - 対策: `Simplify` / `Flatten` / `Graft` の方針を先に決め、後段で辻褄合わせをしない

