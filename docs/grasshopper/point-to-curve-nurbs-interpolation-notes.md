---
order: 37
---

# 付録: NURBS補間（Interpolate）のアルゴリズム要点と制御点抽出

このページは、`point-to-curve-interpolate.md` の補足（数学・内部構造寄り）です。実務で「なぜ暴れるのか」「制御点は何で決まるのか」を説明したい時に参照します。

## アルゴリズムの要点：なぜ制御点で補間点を通せるのか

NURBS曲線は**制御点（control points）**で定義されますが、制御点は通常補間点とは異なる位置にあります。では、なぜ補間点を通る曲線を作れるのでしょうか。

**補間の仕組み（逆算問題）**:

1. **制御点の数と補間点の数の関係**
   - 次数\(p\)のNURBS曲線で\(n\)個の補間点を通るには、**\(n\)個の制御点**が必要です（端点条件が標準的な場合）
   - 補間点の数と制御点の数は**1対1対応**します（\(n\)個の補間点 → \(n\)個の制御点）
   - ただし、制御点は補間点の「単純な関数」\(p = f(v)\) ではなく、**線形システムとして解く**必要があります
   - **例外**: 閉じた曲線や特殊な端点条件の場合、制御点の数が変わる場合がある

2. **連立方程式として解く（線形システム）**
   - 各補間点\(V_i\)について、「NURBS曲線の式にパラメータ\(u_i\)を代入した結果が\(V_i\)になる」という条件を立てます
   - NURBS曲線の式:
     \[
     C(u) = \sum_{j} N_{j,p}(u) \cdot P_j
     \]
     （\(P_j\)は制御点、\(N_{j,p}(u)\)は基底関数）
   - 各補間点\(V_i\)について:
     \[
     V_i = \sum_{j} N_{j,p}(u_i) \cdot P_j
     \]
   - これにより、\(n\)個の補間点から\(n\)個の方程式ができます
   - 未知数は制御点の座標（\(n\)個×3次元 = \(3n\)個）です
   - ノットベクトル（knot vector）を先に決めれば、基底関数\(N_{j,p}(u_i)\)が確定し、**線形システム \(A \cdot P = V\)** として解けます
     - \(A\): \(n \times n\)行列（基底関数の値で構成）
     - \(P\): \(n \times 3\)行列（制御点の座標）
     - \(V\): \(n \times 3\)行列（補間点の座標）
   - **補間点を必ず通る理由**: この連立方程式は、補間点の数と制御点の数が一致する場合、**理論的には完全に解ける**ため、補間点を必ず通る曲線が存在します
   - **数値計算の現実**: 実際の計算では浮動小数点演算の誤差が発生します。Rhinoの公差設定（`DocumentProperties` → Units → Absolute tolerance）内で一致することが多いですが、補間点が極端に不規則な場合や点数が非常に多い場合は誤差が大きくなる場合があります

3. **1対1対応だが、単純な関数ではない**
   - 補間点\(V_i\)と制御点\(P_j\)は1対1対応しますが、\(P_j = f(V_j)\) という単純な関数関係ではありません
   - 各制御点\(P_j\)は、**すべての補間点\(V_1, V_2, \ldots, V_n\)**の情報を使って決定されます
   - つまり、次の形になり、各制御点は全補間点の線形結合です:
     \[
     P_j = \sum_{i} A^{-1}_{j,i} \cdot V_i
     \]
     （\(A^{-1}\)は逆行列）

4. **微分可能性**
   - 補間点\(V\)から制御点\(P\)への写像は**線形写像**（\(P = A^{-1} \cdot V\)）なので、**微分可能**です
   - ノットベクトルが固定されている場合、\(A\)は定数行列なので、\(P = A^{-1} \cdot V\) は線形で、微分は定数行列\(A^{-1}\)になります
   - ノットベクトルも補間点に依存する場合（弦長パラメータ化など）、非線形になりますが、それでも**微分可能**です
   - NURBS曲線\(C(u)\)自体も、パラメータ\(u\)について**無限回微分可能**です（次数3の場合、\(C^2\)連続が保証されます）

5. **制御点から補間点への逆方向の計算**
   - **制御点\(P_j\)がわかれば、補間点\(V_i\)は原理的に計算可能**です
   - 補間点\(V_i\)は、パラメータ値\(u_i\)でNURBS曲線を評価した結果:
     \[
     V_i = C(u_i) = \sum_{j} N_{j,p}(u_i) \cdot P_j
     \]
   - これは**単純な計算**で、連立方程式を解く必要はありません（基底関数\(N_{j,p}(u_i)\)の値と制御点\(P_j\)の線形結合を計算するだけ）
   - ただし、**どのパラメータ値\(u_i\)で評価するか**を決める必要があります（元の補間問題で使ったノットベクトル/パラメータ化を覚えておく必要がある）
   - **非対称性**: 補間点→制御点は連立方程式を解く必要があるが、制御点→補間点は単純な評価計算で済む

6. **ノットベクトルの決定**
   - ノットベクトルは、各補間点に対応するパラメータ値\(u_i\)を定義します
   - 弦長パラメータ化: \(u_i\)は累積弦長に比例（点間距離を反映）
   - 均等パラメータ化: \(u_i\)は均等に割り当て（\(0, \frac{1}{n-1}, \frac{2}{n-1}, \ldots, 1\)）
   - ノットベクトルが決まると、基底関数\(N_{i,p}(u)\)が確定し、連立方程式が解けます

7. **端点条件の扱い**
   - 開いた曲線の場合、端点を必ず通すように制約を追加します
   - 閉じた曲線の場合、最初と最後の点を一致させます

**なぜ振動が起きるのか**:
- 補間点が不規則に配置されている場合、ノットベクトルと補間点の対応が不自然になり、基底関数の組み合わせで大きな係数が発生することがあります
- これにより、制御点が補間点から大きく外れた位置に配置され、曲線が「暴れる」ことがあります

**N個の補間点で生成されるNURBS曲線の構造**:

N個の補間点が与えられた場合、**1本のNURBS曲線**が生成されます。ただし、この曲線は内部的に複数のセグメント（区間）で構成されています。

- **セグメント数**: 次数3の場合、\(n\)個の補間点に対して**\(n-3\)個のセグメント**が生成されます
  - 例: 10個の補間点 → 7個のセグメント
  - 例: 1000個の補間点 → 997個のセグメント
  - 各セグメントは、隣接するセグメントとC²連続（曲率連続）で接続されます
- **セグメント数の計算式**: セグメント数 = 補間点数 - 次数
  - これは、ノットベクトルの構造（端点に次数+1個の重複ノット、内部に\(n-\text{次数}-1\)個のノット）から導かれます
- **1本の曲線として扱われる**: セグメントは内部的に分割されていますが、外部的には1本の連続したNURBS曲線として扱われます
  - `Divide Curve`で分割したり、`Evaluate Curve`で任意のパラメータ値を評価したりできます
- **セグメント境界**: セグメントの境界は、ノットベクトル内の「重複ノット」の位置に対応します
  - 次数3の場合、ノットベクトルは通常 \([0,0,0,0, u_1, u_2, \ldots, u_{n-3}, 1,1,1,1]\) の形式になります
  - 端点（0と1）には次数+1個の重複ノットがあり、内部ノットは補間点に対応します

**なぜセグメント化されるのか**:
- 各セグメントは局所的に制御可能です（局所的な変更が他の部分に影響しにくい）
- しかし、次数が高い場合や補間点が多い場合、1本の長い曲線として扱う方が効率的です
- セグメント境界は、補間点の位置とノットベクトルの構造から自動的に決まります

**NURBS曲線の形状を決める要素**:

- **次数（degree）**: 滑らかさを制御するパラメータ
  - 次数が高いほど滑らかだが、制御が難しくなる
  - 次数3（3次NURBS）は、滑らかさと制御のバランスが良いため、多くの場合に使用される。ただし、角を保持したい場合や制御点を直接編集したい場合は次数を下げる（1次=折れ線、2次=2次曲線）こともある
  - 次数\(p\)の場合、各セグメントは\(p\)次多項式で表現されます
- **ノット（knot / パラメータ化）**: 点列を曲線パラメータ上でどのような間隔として扱うか
  - 弦長パラメータ化: 点間の実際の距離を反映（点が密な箇所はパラメータ間隔が狭い）
  - 均等パラメータ化: 点間の距離に関係なく均等にパラメータを割り当て
  - ノットベクトルの構造がセグメント境界を決定します
- **制御点（control points）**: 曲線を規定する点（補間点そのものではない）
  - 補間の場合、制御点は補間点を通るように逆算で決定される
  - 制御点は補間点から離れた位置にあることが多い（特に点が不規則な場合）
  - 制御点の数は、補間点の数と次数から決まります。標準的な端点条件の場合、補間点数と同じになる。閉じた曲線や特殊な端点条件の場合は異なる場合がある

## 補足: `Evaluate Length`（弧長→点/パラメータ）は「解析解」ではなく「数値近似」

Grasshopperの `Evaluate Length` は、曲線長さ \(L\) のうち「始点から距離 \(s\) の位置」の **点**や **パラメータ \(t\)** を返します。

ただし、NURBSの弧長（\(L(t)=\int_0^t \|C'(u)\|du\)）は一般に**閉形式（解析解）で求められない**ため、実装としては基本的に **数値計算（近似）＋反復探索**になります。

- **何を解いているか**: 「弧長が \(s\) になるパラメータ \(t\)（= \(L(t)=s\) を満たす \(t\)）」を探す
- **なぜ近似になるか**: 弧長積分そのものが一般に解析的に解けないため
- **RhinoCommon側の根拠（tolerance引数）**:
  - `Curve.GetLength(... fractionalTolerance ...)`（指定した許容誤差で長さを求める）
  - `Curve.LengthParameter(... fractionalTolerance ...)`（指定した許容誤差で「弧長→パラメータ」を求める）

参考リンクは `docs/references.md` に追記しました。

## CurveからNURBSの制御点を抽出する

**Q: CurveからNURBSの制御点を抽出するには？**

A: 以下の方法があります：

**方法1: Control Pointsコンポーネント（標準機能、推奨）**

- `Control Points`コンポーネント（Curve → Utilカテゴリ）を使用（Grasshopper標準機能）
- 入力: Curve（NURBS曲線）
- 出力: Point3d[]（制御点のリスト）
- 注意: 入力がNURBS曲線でない場合（例: Polyline、Arcなど）、NURBSに変換されるか、エラーになる場合があります

**方法2: PythonスクリプトでRhinoCommonのAPIを使用**

GrasshopperのPythonコンポーネントで、RhinoCommonの`NurbsCurve`クラスの`Points`プロパティを使用します。

```python
import Rhino.Geometry as rg

# inputs:
#   crv: Curve

if crv:
    # NURBS曲線に変換（必要に応じて）
    if isinstance(crv, rg.NurbsCurve):
        nurbs_crv = crv
    else:
        # 非NURBS曲線をNURBSに変換
        nurbs_crv = crv.ToNurbsCurve()
    
    if nurbs_crv:
        # 制御点を取得
        # outputs:
        #   ctrl_pts: Point3d[]
        ctrl_pts = nurbs_crv.Points  # ControlPointList
        # ControlPointListをPoint3d[]に変換
        a = [ctrl_pts[i].Location for i in range(ctrl_pts.Count)]
    else:
        a = []
else:
    a = []
```

**方法3: 制御点の重み（Weight）も取得したい場合**

制御点の重み（Weight）も取得する場合は、`ControlPointList`から各制御点の`Weight`プロパティを取得します。

```python
import Rhino.Geometry as rg

# inputs:
#   crv: Curve

if crv:
    if isinstance(crv, rg.NurbsCurve):
        nurbs_crv = crv
    else:
        nurbs_crv = crv.ToNurbsCurve()
    
    if nurbs_crv:
        ctrl_pts = nurbs_crv.Points
        # 制御点と重みを取得
        # outputs:
        #   points: Point3d[]
        #   weights: float[]
        a = [ctrl_pts[i].Location for i in range(ctrl_pts.Count)]
        b = [ctrl_pts[i].Weight for i in range(ctrl_pts.Count)]
    else:
        a = []
        b = []
else:
    a = []
    b = []
```

**注意点**:
- 入力がNURBS曲線でない場合（例: Polyline、Arc、Lineなど）、`ToNurbsCurve()`で変換する必要があります
- 変換後の制御点数は、元の曲線の種類によって異なります（例: Lineは2点、Arcは複数点）
- 制御点の順序は、曲線のパラメータ方向（開始点→終了点）に対応します

